---
title: C++默认参数
index: true
# icon: code
tag: C++
star: true
---
## C++默认参数

### 1. 默认实参之后的参数也必须拥有默认实参
```cpp
void f(int ,int = 6,int);
void f(int =4,int,int);
void f(int a,int b,int c);{std::count<<a<<''<<''<<c<<'\n'}

int main(){
fn(4,6,10);
}
```
上面代码运行不会由任何问题。
原因：在函数声明中所拥有的默认实参之后的形参必须拥有在这个或同一作用域中先前的声明中所提供的默认实参。但是必须在当前作用域提前给已经声明了默认实参数后面的形参默认参数。例如：
```cpp
void f(int ,int = 6,int);
void f(int,int,int =10);
void f(int =4,int,int);
```
调整顺序后，第二个形参拥有默认实参没有问题。但是在此之前第三个形参也必须拥有默认实参才可以。

### 2. 非模板类的成员函数默认实参必须与类内的声明组合

对于非模板类的成员函数，类外定义中允许出现默认实参数，并于类体内的声明所提供的默认参数相组合。如果类外的默认实参会使成员函数变成默认构造函数或复制/移动（C++11起）构造函数/赋值运算符，那么程序非良构。对于类模板的成员函数，所有默认实参必须在成员函数初始声明处提供。


。
### 3. C++ 形参包展开有 6 个点
基本包展开template<typename... Args> // 类型形参包
```cpp
void f(Args...args){       // 函数形参包
    // 创造合适的包展开场所（花括号包围的初始化器）
    int _[]{ (std::cout << args << ' ',0)... };

    std::cout << '\n';

    // C++17 折叠表达式展开
    ((std::cout << args << ' '), ...); 
}
```
运行测试。这些都是使用了三个点 ... 进行展开。的确，包展开的语法就是三个点。6 个点 Args...... 的特殊情况我之所以会说有 6 个点的情况，那是因为在某些特殊情况下会叠加使用：
```cpp
template<class Ret, class... Args>
void f(Ret(*func)(Args......)) {
    func(1); // 调用函数指针
}
```
运行测试。这里的 Args...... 出现了 6 个点。其实不用感到奇怪，记住我们以往教程说的话：C++ 的类型就和拼图一样。既然 C++ 形参包展开的语法只有三个点，那么我们就按照已知的去思考。假设我们传入了 void 、int 类型，带入进去。Ret 就是 void ，Args... 展开就是 int，加上没有用到的那 ... 那么组合起来是？void(*func)(int...)
发现了吗？C 语言变长实参罢了，C++11 允许了变长实参的三个点可以不以逗号分隔。当然我们也可以继续用逗号分隔，例如：
```cpp
template<class Ret, class... Args>
void f(Ret(*func)(Args...,...));
```
中间加了一个逗号变成了 ...,...，这也是可以的的。完整代码：
```cpp
template<class Ret, class... Args>
void f(Ret(*func)(Args......)) { // 加不加逗号都行
    func(1); // 调用函数指针
}

// 带可变参数的示例函数
void func(int a, ...) { // 加不加逗号都行
    std::cout << "沙贝 C 变长实参函数" << a << std::endl;
}

int main() {
    f(func);
}
```